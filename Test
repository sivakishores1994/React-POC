import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { Provider } from "react-redux";
import { MemoryRouter } from "react-router-dom";
import configureStore from "redux-mock-store";
import Dashboard from "./Dashboard";

// Mocks
jest.mock("react-redux", () => ({
  useDispatch: jest.fn(),
  useSelector: jest.fn((fn) => fn()),
}));
jest.mock("react-router-dom", () => ({
  useNavigate: jest.fn(),
  useLocation: jest.fn().mockReturnValue({ search: "?auth=resume" }),
}));

// Mock services and actions
jest.mock("../../services/common-service", () => ({
  dispatchLoader: jest.fn(),
  getClientInfo: jest.fn(),
  resumeRequest: jest.fn(),
  uploadRequest: jest.fn(),
  getBancaEligibleProducts: jest.fn(),
}));

jest.mock("../../utils/store/auth-slice", () => ({
  authAction: { getSession: jest.fn() },
}));
jest.mock("../../utils/store/stages-slice", () => ({
  stagesAction: {
    setJourneyType: jest.fn(),
    getStage: jest.fn(),
    updateUserInputFields: jest.fn(),
    updateTaxFields: jest.fn(),
  },
}));
jest.mock("../../utils/common/change.utils", () => ({
  getUrl: {
    getParameterByName: jest.fn(() => "resume"),
    getLoader: jest.fn(() => ({ cta: true })),
  },
}));

const mockStore = configureStore([]);

describe("Dashboard Component", () => {
  let store;
  let mockDispatch;

  beforeEach(() => {
    store = mockStore({
      stages: { stages: [], journeyType: "ETC", otpOpen: false },
      urlParam: { myInfo: false, validUrl: true },
    });

    mockDispatch = jest.fn();
    jest.requireMock("react-redux").useDispatch.mockReturnValue(mockDispatch);
  });

  test("renders without crashing", () => {
    render(
      <Provider store={store}>
        <MemoryRouter>
          <Dashboard />
        </MemoryRouter>
      </Provider>
    );

    expect(screen.getByText(/loading/i)).toBeInTheDocument(); // Ensure loading or initial state is displayed
  });

  test("renders popup model if URL is invalid", () => {
    store = mockStore({
      urlParam: { myInfo: false, validUrl: false },
      stages: { stages: [], journeyType: "ETC", otpOpen: false },
    });

    render(
      <Provider store={store}>
        <MemoryRouter>
          <Dashboard />
        </MemoryRouter>
      </Provider>
    );

    expect(screen.getByText(/globalError/i)).toBeInTheDocument();
  });

  test("dispatches loader and URL parameter actions on load", () => {
    render(
      <Provider store={store}>
        <MemoryRouter>
          <Dashboard />
        </MemoryRouter>
      </Provider>
    );

    expect(mockDispatch).toHaveBeenCalledWith(expect.any(Function));
    expect(mockDispatch).toHaveBeenCalledWith({
      type: expect.stringContaining("urlParam/getUrlParameter"),
    });
  });

  test("renders Fields component when fieldsComponent state is true", () => {
    store = mockStore({
      stages: { stages: [], journeyType: "ETC", otpOpen: false },
      urlParam: { validUrl: true },
    });

    render(
      <Provider store={store}>
        <MemoryRouter>
          <Dashboard />
        </MemoryRouter>
      </Provider>
    );

    // Simulate fieldsComponent being set to true
    fireEvent(window, new Event("resize"));
    expect(screen.queryByText(/Fields/i)).toBeNull(); // Modify based on Fields content
  });

  test("adds resize event listener on mount and removes it on unmount", () => {
    const { unmount } = render(
      <Provider store={store}>
        <MemoryRouter>
          <Dashboard />
        </MemoryRouter>
      </Provider>
    );

    const resizeSpy = jest.spyOn(window, "addEventListener");
    expect(resizeSpy).toHaveBeenCalledWith("resize", expect.any(Function));

    unmount();
    const removeSpy = jest.spyOn(window, "removeEventListener");
    expect(removeSpy).toHaveBeenCalledWith("resize", expect.any(Function));
  });
});
