import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { useDispatch, useSelector } from 'react-redux';
import Alias from './Alias';
import { getFields } from './alias.utils';
import renderComponent from '../../../modules/dashboard/fields/renderer';
import { constant } from './constant';

jest.mock('react-redux', () => ({
  useDispatch: jest.fn(),
  useSelector: jest.fn(),
}));

jest.mock('./alias.utils', () => ({
  getFields: jest.fn(),
}));

jest.mock('../../../modules/dashboard/fields/renderer', () => jest.fn());

describe('Alias Component', () => {
  const mockDispatch = jest.fn();
  const mockGetFields = jest.fn();
  const mockRenderComponent = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    (useDispatch as jest.Mock).mockReturnValue(mockDispatch);
    (useSelector as jest.Mock).mockImplementation((selectorFn) => {
      if (selectorFn.name === 'stageSelector') {
        return [{ id: 'stage1', name: 'Stage 1' }];
      }
      if (selectorFn.name === 'journeyType') {
        return false;
      }
      if (selectorFn.name === 'aliasSelector') {
        return { count: 1, maxCount: 5 };
      }
      return {};
    });
    (getFields as jest.Mock).mockImplementation(mockGetFields);
    (renderComponent as jest.Mock).mockImplementation(mockRenderComponent);
  });

  it('should render without crashing', () => {
    render(<Alias handleCallback={jest.fn()} handleFieldDispatch={jest.fn()} value="" />);
    expect(screen.getByPlaceholderText(constant.placeholder)).toBeInTheDocument();
  });

  it('should call getFields on initial render with "get" action', () => {
    render(<Alias handleCallback={jest.fn()} handleFieldDispatch={jest.fn()} value="" />);
    expect(mockDispatch).toHaveBeenCalled();
    expect(mockGetFields).toHaveBeenCalledWith(
      [{ id: 'stage1', name: 'Stage 1' }],
      { count: 1, maxCount: 5 },
      'get'
    );
  });

  it('should update fields on button click for "add" action', () => {
    render(<Alias handleCallback={jest.fn()} handleFieldDispatch={jest.fn()} value="" />);
    const button = screen.getByPlaceholderText(constant.placeholder);
    fireEvent.click(button);
    expect(mockDispatch).toHaveBeenCalled();
    expect(mockGetFields).toHaveBeenCalledWith(
      [{ id: 'stage1', name: 'Stage 1' }],
      { count: 1, maxCount: 5 },
      'add'
    );
  });

  it('should render components dynamically based on fields', () => {
    const mockFields = [
      { id: 'field1', name: 'Field 1' },
      { id: 'field2', name: 'Field 2' },
    ];
    (getFields as jest.Mock).mockReturnValue(mockFields);

    render(<Alias handleCallback={jest.fn()} handleFieldDispatch={jest.fn()} value="" />);
    expect(mockRenderComponent).toHaveBeenCalledTimes(mockFields.length);
    mockFields.forEach((field, index) => {
      expect(mockRenderComponent).toHaveBeenCalledWith(
        field,
        index,
        expect.any(Function),
        expect.any(Function),
        ''
      );
    });
  });

  it('should hide button when maxCount is reached', () => {
    (useSelector as jest.Mock).mockImplementation((selectorFn) => {
      if (selectorFn.name === 'aliasSelector') {
        return { count: 5, maxCount: 5 }; // maxCount reached
      }
      return {};
    });

    render(<Alias handleCallback={jest.fn()} handleFieldDispatch={jest.fn()} value="" />);
    const button = screen.queryByPlaceholderText(constant.placeholder);
    expect(button).not.toBeVisible();
  });
});
